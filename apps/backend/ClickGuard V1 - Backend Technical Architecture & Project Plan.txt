ClickGuard V1 - Backend Technical Architecture & Project Plan
1. Project Overview & Architectural Principles
1.1. Objective
To build the backend infrastructure for ClickGuard, a SaaS platform that provides real-time click fraud detection and automated IP blocking for Google Ads campaigns. The system must be highly available, scalable to handle high-throughput click data, and maintainable.
1.2. Core Principles
* Asynchronous Processing: The core principle is to decouple the high-volume data ingestion from the slower, more intensive processing tasks. We will never make a user or a tracker wait for a slow operation (like an external API call or complex database query).
* Scalability & Separation of Concerns: The architecture will be a Modular Monolith. While contained within a single codebase for V1 simplicity, services will be logically separated and communicate via a message queue. This allows us to scale different parts of the application independently (e.g., add more processing workers without scaling the main API server).
* Resilience: The use of a message queue ensures that even if a downstream service (like the Google Ads API or our database) is temporarily unavailable, incoming click data is not lost. It will be safely queued and processed when the service recovers.
* Single Responsibility: Each service or worker has a single, well-defined job.
2. High-Level Architecture: A Queue-Based System
The system's core is a message queue that separates three main processes:
1. Ingestion: A lightweight API endpoint that does nothing but accept incoming click data and push it into a queue.
2. Processing: A pool of workers that consume data from the queue, enrich it, run it through a rule engine, and decide if an action is needed.
3. Action: A dedicated worker that takes action based on the processor's decision (e.g., calls the Google Ads API to block an IP).
![Architecture Diagram Placeholder: A simple diagram showing [Tracker API] -> [RabbitMQ: click_processing_queue] -> [Processing Worker] -> [RabbitMQ: google_ads_actions_queue] -> [Google Ads Action Worker] -> [Google Ads API]. A separate line shows [Google Ads Action Worker] -> [WebSocket Service] -> [Frontend Dashboard].]
3. Technology Stack & Libraries (Node.js Ecosystem)
This section details the specific technologies and libraries chosen to build the backend.
* Core Framework:
   * Express.js: A minimal and flexible Node.js web application framework. It provides a robust set of features for web and mobile applications without obscuring Node.js features.
* Database:
   * PostgreSQL: A powerful, open-source object-relational database system with a strong reputation for reliability, feature robustness, and performance.
   * Sequelize: A modern TypeScript & Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, eager and lazy loading, read replication and more.
* Message Queue:
   * RabbitMQ: A robust and scalable open-source message broker.
   * amqplib: The most popular and well-maintained AMQP 0-9-1 client for Node.js, for interacting with RabbitMQ.
* Authentication & Authorization:
   * Passport.js: A simple, unobtrusive authentication middleware for Node.js. We will use the passport-google-oauth20 strategy for handling Google sign-in.
   * jsonwebtoken (JWT): For creating and verifying session tokens to secure the API endpoints.
* Real-time Communication:
   * Socket.IO: Enables real-time, bidirectional and event-based communication. It will be used for the Live Threat Feed on the dashboard.
* API Clients & HTTP Requests:
   * Google Ads API Client: @google-ads/google-ads-api - The official Node.js client library provided by Google.
   * Axios: A promise-based HTTP client for the browser and Node.js. It will be used to make requests to the external IP Reputation API.
* Validation:
   * Joi: A powerful schema description language and data validator for JavaScript. Used for validating incoming request bodies, headers, and environment variables.
* Utilities & Process Management:
   * dotenv: A zero-dependency module that loads environment variables from a .env file into process.env.
   * PM2: A production process manager for Node.js applications with a built-in load balancer. It allows you to keep applications alive forever, to reload them without downtime and to facilitate common system admin tasks.
4. Directory Structure (for AI Code Generator)
A clear, logical structure is essential.
/clickguard-backend
|
├── /src
│   ├── /api
│   │   ├── /controllers        # Handles HTTP request/response logic (e.g., dashboardController.js)
│   │   ├── /routes             # Defines API routes (e.g., dashboard.routes.js)
│   │   └── /middleware         # Express middleware (e.g., authenticate.js)
│   │
│   ├── /config                 # Configuration files (database, environment, etc.)
│   │
│   ├── /models                 # Database schemas/models (e.g., User.js, ClickLog.js)
│   │
│   ├── /services               # Core business logic, decoupled from HTTP
│   │   ├── googleAds.service.js # Interacts with Google Ads API
│   │   ├── ipReputation.service.js # Interacts with IP reputation API
│   │   ├── ruleEngine.service.js   # The fraud detection logic
│   │   ├── websocket.service.js  # Manages WebSocket connections and events
│   │   └── queue.service.js        # Manages connection to RabbitMQ
│   │
│   ├── /workers                # Long-running background processes
│   │   ├── clickProcessor.worker.js # Consumes from click_processing_queue
│   │   └── googleAdsAction.worker.js # Consumes from google_ads_actions_queue
│   │
│   └── /utils                  # Helper functions
│
├── .env.example                # Environment variable template
├── package.json
└── server.js                   # Main entry point, starts server and workers

5. Core Component Specifications
5.1. The Tracker API Endpoint (POST /api/v1/track)
* Responsibility: To be extremely fast and resilient. Its ONLY job is to validate the incoming data packet and push it to the message queue.
* Logic:
   1. Receive a POST request.
   2. Validate the X-API-Key header to identify the client account.
   3. Validate the request body to ensure it has the required fields (ipAddress, userAgent, keyword, etc.).
   4. If valid, publish the raw click data as a message to the click_processing_queue.
   5. Immediately return a 202 Accepted response.
5.2. The Message Queue (RabbitMQ)
* Why RabbitMQ: It's robust, supports message persistence (so we don't lose data on a server restart), and is perfect for the worker queue pattern.
* Queues to Define:
   * click_processing_queue: Holds raw click data waiting to be analyzed.
   * google_ads_actions_queue: Holds jobs for the Google Ads API, like "block this IP".
5.3. The Click Processing Worker (clickProcessor.worker.js)
* Responsibility: The brain of the operation. It runs as a separate, continuous background process.
* Logic:
   1. Connect to RabbitMQ and subscribe to the click_processing_queue.
   2. On receiving a message (a raw click object):
a. Enrich Data: Call the ipReputation.service.js to get metadata for the IP address (isVPN, isProxy, country, etc.).
b. Run Rules: Pass the enriched click data to the ruleEngine.service.js.
c. Get Decision: The Rule Engine returns a decision object, e.g., { action: 'BLOCK_IP', reason: 'VPN Detected', priority: 'HIGH' } or { action: 'MONITOR', reason: 'Low Session Duration' }.
d. Log to Database: Save the enriched click data and the decision to the ClickLogs table.
e. Take Action (Indirectly): If the decision requires an action (like BLOCK_IP), publish a new message to the google_ads_actions_queue. The message should contain all necessary info, e.g., { ipToBlock: '85.102.34.11', clientGoogleAdsId: '...', reason: '...' }.
   3. Acknowledge the original message from click_processing_queue to remove it.
5.4. The Google Ads Action Worker (googleAdsAction.worker.js)
   * Responsibility: To safely and reliably interact with the external Google Ads API.
   * Logic:
   1. Connect to RabbitMQ and subscribe to the google_ads_actions_queue.
   2. On receiving a message (an action job):
a. Call the googleAds.service.js to perform the action (e.g., add the IP to the client's exclusion list).
b. On Success:
i. Update the BlockedIPs table in the database.
ii. Call websocket.service.js to broadcast a real-time event (IP_BLOCKED) to the relevant client's dashboard.
c. On Failure: Implement a retry mechanism with exponential backoff (e.g., if the Google API is temporarily down).
   3. Acknowledge the message from google_ads_actions_queue.
5.5. WebSocket Service (websocket.service.js)
      * Technology: socket.io library.
      * Responsibility: Manages all active dashboard connections. It should map socket IDs to authenticated user IDs.
      * Logic:
      * Exposes a function like emitToUser(userId, eventName, payload).
      * The googleAdsAction.worker.js calls this function after a successful block to send the real-time update to the correct user's browser.
6. Data Models (Database Schema - PostgreSQL/Sequelize)
// models/User.js
{
 id: { type: DataTypes.UUID, primaryKey: true, defaultValue: DataTypes.UUIDV4 },
 email: { type: DataTypes.STRING, unique: true, allowNull: false },
 googleId: { type: DataTypes.STRING, unique: true },
 subscriptionStatus: { type: DataTypes.ENUM('active', 'inactive', 'trial'), defaultValue: 'trial' },
 apiKey: { type: DataTypes.STRING, unique: true, allowNull: false }
}

// models/ConnectedAccount.js
{
 id: { type: DataTypes.UUID, primaryKey: true },
 userId: { type: DataTypes.UUID, references: { model: 'Users', key: 'id' } },
 googleAdsAccountId: { type: DataTypes.STRING, unique: true },
 accessToken: { type: DataTypes.TEXT, allowNull: false }, // Encrypted
 refreshToken: { type: DataTypes.TEXT, allowNull: false } // Encrypted
}

// models/ClickLog.js
{
 id: { type: DataTypes.BIGINT, primaryKey: true, autoIncrement: true },
 accountId: { type: DataTypes.UUID, references: { model: 'ConnectedAccounts', key: 'id' } },
 ipAddress: { type: DataTypes.STRING, allowNull: false },
 userAgent: { type: DataTypes.TEXT },
 keyword: { type: DataTypes.STRING },
 gclid: { type: DataTypes.STRING },
 isVpn: { type: DataTypes.BOOLEAN },
 isProxy: { type: DataTypes.BOOLEAN },
 isHosting: { type: DataTypes.BOOLEAN },
 country: { type: DataTypes.STRING },
 fraudScore: { type: DataTypes.INTEGER },
 decision: { type: DataTypes.JSONB }, // { action: 'BLOCK_IP', reason: '...' }
 timestamp: { type: DataTypes.DATE, defaultValue: DataTypes.NOW }
}
// --> Add indexes on: accountId, ipAddress, timestamp

// models/BlockedIP.js
{
 id: { type: DataTypes.BIGINT, primaryKey: true, autoIncrement: true },
 accountId: { type: DataTypes.UUID, references: { model: 'ConnectedAccounts', key: 'id' } },
 ipAddress: { type: DataTypes.STRING, allowNull: false },
 reason: { type: DataTypes.STRING },
 blockTimestamp: { type: DataTypes.DATE, defaultValue: DataTypes.NOW }
}
// --> Add a composite unique index on: [accountId, ipAddress]

7. Environment Variables (.env)
# Application
NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/clickguard

# Authentication
JWT_SECRET=a_very_strong_and_long_secret_key

# Google OAuth & API
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
GOOGLE_ADS_DEVELOPER_TOKEN=your_developer_token

# Queue
RABBITMQ_URL=amqp://localhost

# External Services
IP_REPUTATION_API_KEY=your_ipqualityscore_or_maxmind_key

This technical plan provides a solid, scalable foundation for V1. It addresses the core performance challenges upfront and creates a modular system that is ready for future expansion.